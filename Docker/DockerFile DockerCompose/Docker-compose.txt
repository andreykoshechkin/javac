version: '3'				#Указывается версия

services:
  app:					#Указывается имя, имя может быть любым, главное указать где находится dockerfile для нужного сервиса.
    build: ./app			#Указывается расположение dockerfile для сервиса app
    ports:				#Указываются порта. 3333 - внешний порт, 3000 порт внутри контейнера
      - '3333:3000'
    depends_on:				#Опция, которая запустит собирет образ app(это бекенд), только после того, как service контейнер mysql будет запущен. Сначала запуститься контейнер mysql и только потом service app.
      - database			


  frontend:				#Указывается имя, имя может быть любым, главное указать где находится dockerfile для нужного сервиса.
    build: ./frontend			#Указывается расположение dockerfile для сервиса frontend
    ports:				#Указываются порта. 3333 - внешний порт, 3000 порт внутри контейнера
      - '5555:5000'
    restart: always			#Если будет ошибка, или контейнер остановится, то service frontend будет перезапущен		
  
  database:				#Опять же, название может быть любым, в нашем примере я захотел назвать database.
    image: mysql			#Образ который docker загрузит. Порт не указывается! доступ к базе данных будет внутри, а не снаружи
    environment:
        MYSQL_ROOT_PASSWORD: password	#Указывем пароль. Пароль должен совпадать с тем паролем, который использует сервис backend, в нашем случае, app - backend.
        MYSQL_DATABASE: time_db		#Указывем имя БД. Пароль должен совпадать с тем паролем, который использует сервис backend, в нашем случае, app - backend.
  adminer:
    image: adminer
    ports:
      - '8888:8000'

===================
Команды при работе с docker-compose:
1. docker-compose up		#Собирет все образы, что есть в docker-compose.yml в один контейнер.
2. docker-compose up -build	#Пересоздаст необходимые образы, используется тогда, когда в docker-compose.yml были изменения
3. docker-compose up		#Запуск в бекраунде.
4. docker-compose down		#Остановит весь контейнер.