Декартовое множество - ситуация, когда запись из одной таблице, дублируется с записью из другой таблице

fetch = FetchType.LAZY НУЖНО ИСПОЛЬЗОВАТЬ ВЕЗДЕ

fetch = FetchType.EAGER - Не стоит использовать, так как это повлияет на производительность в худшую сторону, по причине того, что возникнет декартовое множество
а так же, если в нашей сущности, маппинг @OneToMany реализован с помощью PersistentBag то мы получим исключение MultipleBagFetchException 
по причине того, что PersistentBag не поддерживает сортировку 

Если мы везде поставим FetchType.EAGER а маппинг @OneToMany будет использовать PersistentSet "private Set<Payments> payments = new HashSet<>();"
   то в таком случае, hibernate вернет нам данные из бд в рамках одного запроса НО мы получим декартовое множество

FetchType.EAGER не работает для HQL, Criteria API, Qarydsl запросов(мы не можем использовать Limit, offset,  аггригирующие функции, так как строк будет очень много)

================================================================================================================================================================
 
  @Builder.Default
    @OneToMany(mappedBy = "employee", fetch = FetchType.EAGER)
    private List<Payment> paymentList = new ArrayList<>();


    @OneToMany(mappedBy = "employee", fetch = FetchType.EAGER)
    private List<Profile> profiles = new ArrayList<>(); 
В этом случае мы получим исключение MultipleBagFetchException

===========================================================================================================================================================

FetchType  -- позволяет получать допалнительные сущности. Имеет два параметра:
fetch = FetchType.EAGER < жадная загрузка,  используется у одного объекта (к того объекта, который помечен аннотацией @ManyToOne)
fetch = FetchType.LAZY  < ленивая загрузка, используется у коллекций. Создает прокси нашего объекта. Прокси создается только тогда, когда мы получаем сущность
Когда какой-то объект имеет fetchTybe.LAZY, то сам объект вызываться не будет, Вместо него будет вызван прокси этого объекта

===========================================================================================================================================================

Отличие между EAGER и LAZY заключается в том как данные загружаются в память.
LAZY  --- инициализация происходит когда мы явно вызываем его, используя getter или какой-либо другой метод 
EAGER --- он будет инициализирован сразу в первой строке:
Для ленивой загрузки мы используем прокси-объект и запускаем отдельный SQL-запрос для загрузкиorderDetailSet.