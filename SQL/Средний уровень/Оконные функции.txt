Оконные функции: Механизм, который позволяет отображать информацию по группу.

Оконная функция выполняет вычисления для набора строк, некоторым образом связанных с текущей строкой. 
Можно сравнить её с агрегатной функцией, но, в отличие от обычной агрегатной функции, 
при использовании оконной функции несколько строк не группируются в одну, 
а продолжают существовать отдельно. Внутри же, оконная функция, как и агрегатная, может обращаться не только к текущей строке результата запроса.


Можно сравнить их с агрегатными функциями, но, в отличие от обычной агрегатной функции, 
при использовании оконной функции несколько строк не группируются в одну, а продолжают существовать отдельно
=====================================================================================================================================================================
OVER () 	//позволяет пердставить нашу таблицу ввиде оконной функции
rank()		//позволяет ранжировать по заданному значению. для корректного результата, нужно сортировать (Пример: rank() OVER (ORDER BY e.salary))
dense_rank()	//позволяет ранжировать по заданному значению не пропускает нумерацию
row_number() 	//нумерует и отображает строки в выборки 
partition by	//Разбивает окно по значение
nulls_first 	//null значения будут в начале 
lag()		//показывает предыдущее значение(в параметры передаем тот элемент, по которому мы хотим получить выборку) (Показывает зарплату у предыдущего employee)
lead()		//Показываем следующее значение((в параметры передаем тот элемент, по которому мы хотим получить выборку))


SELECT com.name,
       eml.username,
       eml.salary,
       lag(eml.salary) OVER (PARTITION BY com.id ORDER BY eml.salary DESC),
       dense_rank() OVER (PARTITION BY com.id ORDER BY eml.salary DESC ),
       lead(eml.salary) OVER (PARTITION BY com.id ORDER BY eml.salary DESC  )

FROM company com
          JOIN employee eml ON com.id = eml.company_id
WHERE com.name IN ('Google', 'Telegram')
	

=====================================================================================================================================================================


SELECT
    company.name,
    --count(*) OVER (),
    dense_rank() OVER (partition by company.na	 me ORDER BY e.salary), 
    e.first_name,
    e.salary
FROM company LEFT JOIN employee e on company.id = e.id_company
=====================================================================================================================================================================

SELECT c.name,
       e.last_name,
        rank() OVER (partition by c.name ORDER BY e.salary nulls first ) 	<--- Создадим оконную функцию,  которая разбивае  имена компаний на группы , сортируем и указываем, что первым элементом будет 
							        та компания,у которой salary null

FROM company c
         LEFT JOIN employee e ON c.id = e.company_id