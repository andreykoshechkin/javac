<?> Любой класс
<? extends > - класс X и его потомки
<? super Y> - класс Y любой его суперкласс 



Generics:			//Это сущность, которая отвечают за контроль типа данных во время компиляции. И Generics позволяют создавать обобщенные (generic)
				 классы и методы, которые могут работать с разными типами данных, при этом обеспечивая безопасность типов.
				
 				//По умолчанию вместо generics, java использует в Колекциях тип данных Object 
					 и это не совсем верный подход так как в колекцию мы сможем добавить разные типы данных,
					 при прменить upcasting мы не сможем
				 	 возникнет исключение(CastFoundExeption)
				//Generics не поддерживают приметивные типы.

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

Parameterized class		// Это тот класс, который может принимать еще не известные параметры, То есть, когда в сигнатуре класса мы пишем
				   тип <T> а внутри класса, мы создаем переменную типа private T name, то мы как бы говорим, java присвой переменной name, 
				   тот тип данных, который будет указан при создании объекта. 

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

Parameterized method		//Праметризованный метод, нужен в тех ситуациях, когда мы не знаем с каким типом данных будем работать.
  					public static <T> T getIndexList  (ArrayList<T> arr) (<T> - указывает, на generics, Вторая T - return type)
 				        return arr.get(1);

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

Type erasure			//Стирание данных о Generics. Это необходимая операция для поддержки обратной совместимости для более страхы версиях java, где поддержка generics не предусмотренна, 

				 generics, должен работать там где generics не поддерживаются. Это происходит из-за того, что java 
				  в фоновом режиме стирает данные о generics.
				  При использование generis, методы не могут быть переопределенны или быть перезагружены. Это происходит
				  по той причине, что java воспринимает generic как Объект с типом Object
				
				//Если мы хотим, чтобы наша <T> была именно каким-то числом(не важно каким именно) то мы должны extands Number 
					class Person<T extends Number>

Subtyping			//Number - являеться родителем всех Integer Double Long и тд;
				//В ситуациях, когда мы хотим, чтоб наш метод принмал в качестве параметром объектны конкретного типа, то мы можем записать
				Следующее #1: public <T extends Number> T abc(ArrayList<T> arrayList) - этот метод будет примать ArrayList только из чисел.
				Следующее #2: public <T extends Animal> T abc(ArrayList<T> arrayList) - этот метод будет примать ArrayList  Animal.

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

Wildcards			//Wildcards Позволяет не привязывать колекцию к конкретному типу.Пример   
				  static void retList(List<?> list) - <?> позволяет работать с list с любыми параметрами, будь это Integer or String итд.
				  static void retList(List<? extends Number> list) позволяет работать с list исключительно с потомками Integer итд.
				 
			         | List<?> list = new Arraylist<>(); Так делать нельзя! java будет понимать что в лист мы добавляем string. 		|
				 | list.add("SASA");		     Но Java понятия не имеет какой тип данных будет у листа. Поэтому возникнет ошибка  |
	

