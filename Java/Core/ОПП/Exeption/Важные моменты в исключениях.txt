
1:Finally block всегда выполняется заисключением ситуаций, когда мы  завершаем работу с помощью метода System.exit или Произошло крушение  
2:Finally block нужен для написание какого-то важного кода, к примеру для закрытие соединения или потока; 
3: finally block выполниться даже если в методы мы должны что-то вернуть
4: если return type есть в try catch finally блоке то возвращаемое значение будет из finally блока
5: если мы не можем полностью обработать исключение, то тогда мы можем перебросить исключение в блоке catch!. В блоке catch нужно указать throw, а в сигнатуре
методы thorows. Кроме не проверяемых исключений.  
6: если в качестве возвращаемого значение у нас примитив, то в finally блоке мы не сможем изменить его, а вот если в качестве возвращаемого значение 
ссылочный тип данных, тогда в finally блоке мы сможем его изменить.
7: Внутри try catch блока может быть внутренний try catch блок

Если во  внешнем блоке try есть исключение, то во внутрений блок мы не зайдем. Если во  внешнем блоке try нет исключения, мы зайдем во внутренний и если 
там будет исключение, то выполнится внутренний catch. 


Если в классе родителя, какой-то метод выбрасывает проверяемое исключение, то переопределив этот метод, мы не сможем выбрасить исключение, 
которое стоит выше в иерархии наследования исключений
(Если методок родителя выбрасывает IOExceptiont то переопределенный метод не может выбросить Exceptiont). При этом, мы можем выбрасывать не проверяемые 
исключения. 

Если речь идет о перегруженных методах, то правило с преопределенными методами не работает. Пререгруженные методы 
могу бросать любые исключение вне зависимости от иерархии.

Конструктор может выбрасывать исключенич. Перегруженный конструктор обязан вызвать все исключени конструктора
из главного конструктора

throws - выбрасывает исключение в сигнатуре метолда
throw - создает новое исключение 