Синхронизированные колекции делятся на две группы:
						 №1 //Синхронизированные коллекции, те коллекции у которых потокобезопастность  достигается 
						      при помощи synchronized оберток, которая есть у класса 
						      Collections и называется она synchronizedList(synchronizedMap, synchronizedSet);
						      List<Integer> l2 = Collections.synchronizedList(new ArrayList<>());

						    //При помощи обертки, коллекции начинают использовать lock на своих методах. 
						      по этой причине, с одним листом может работать только один поток.
						      (Когда мы используем какой-то метод, на этом методе будет
						      стоять блокировка и пока эта блокировка стоит, другие потоки не смогут пользоваться этим методом)

						    //Итераторы не всегда работают коректно при работе с потоками, зачастую выбрасывает исключение ConcurrentModificationException. 
							 Это происходит из-за того, что во время перебора, элементы колекции уже могут быть изменены.
							 во избежания выброса исключения, нужно поместить итератор в синхронайз блок, а в качестве монитора использовать лист.


							 Runnable runnable = () -> {
        						    synchronized (synchList) {
             						   Iterator<Integer> integerIterator = synchList.iterator();

               						 while (integerIterator.hasNext()) {
                  					  System.out.println(integerIterator.next());
               						 }
          						}
  						      };

	

						#2 // Conncurent коллекции-это конкретные колекции, которые изначально были синхронизированны 





