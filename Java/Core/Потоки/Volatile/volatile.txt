				
Volatile - используется тогда, когда один поток записывает, а другой поток читает
Volatile - указывается у переменной.	//  private static boolean aFlag = false;
Volatile - работает только для приметивов и для ссылок. К сожалению, содержимое ссылки мы не можем посмотреть, но можем узнать изменилась ли ссылка


volatile - это ключевое слово, указывается у переменной и volatile позволяет избежать попадания переменной в кеш ядра! благодоря чему, переменная становится не доступной для других cpu
вместо этого volatile помещает переменну в основную память.Именно по этой причине мы можем получить более свежие значения переменной,
в противном случаи, мы могли получить устаревшие значения из кеша. Собственно, когда один поток записывает, а другой поток считывает нам нужно использовать
volatile, иначе может возникнуть некий хаос 

Пример: java распределила два потока на два ядра(для трех потоков на три ядра и тд)
на каждом ядре выполняется свой поток и может случится так, что второй потоко добавит нашу переменную в свой кеш, тогда наша переменная всегда будет иметь
то значение, которое попало в кеш. И если первый поток изменит переменную, то второй поток будет всегда считывать то значение, которое попало ему в кеш


Проблема когерентности  кеша:		//Это случай, когда один поток записывает какие-то данные в переменную, а второй поток паралельно читает эту переменную и 
					  может случится так, что второй поток закеширует переменную и когда первый поток изменить переменную, то второй поток не 
					  получит свежие данные. volotile помогает избежать когерентности  кеша.
Проблема когерентности кеша (В кратце) //Это случай, когда значение переменной попало в кеш cpu

Пример:
у нас есть булевская переменная со значение true, оба  потока считывают эту переменную, но может произойти так, что значение переменной попала в кеш второго потока, то есть
в кеше второго потока будет всегда true и когда первый поток поменяет значение переменной с true на false второй поток уже не примет эти изменения

 
